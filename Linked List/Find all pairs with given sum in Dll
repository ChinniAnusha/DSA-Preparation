#Brute force
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev


# Don't change the code above.


def findPairs(head: Node, k: int) -> [[int]]:

    # Write your code here.
    # Return boolean true or false.
    t1 = head
    pairs = []
    while t1 is not None:
         t2 = t1.next
         while t2 is not None:
             if t1.data + t2.data == k:
                 pairs.append([t1.data,t2.data])
             t2 = t2.next
         t1 = t1.next
    
    return pairs
#TC:~ O(n^2)
#SC:O(1)

#Optimal using two pointers
class Node:
    def __init__(self, data=0, next=None, prev=None):
        self.data = data
        self.next = next
        self.prev = prev


# Don't change the code above.
def findtail(head):
    tail = head
    while tail.next is not None:
        tail = tail.next
    return tail

def findPairs(head: Node, k: int) -> [[int]]:

    # Write your code here.
    # Return boolean true or false.
    t1 = head
    listt = []
    t2 = findtail(head)
    while t1.data < t2.data:
      if t1.data+t2.data == k:
        listt.append([t1.data,t2.data])
        t1 = t1.next
        t2 = t2.prev
      elif t1.data+t2.data > k:
          t2 = t2.prev
      else:
          t1 = t1.next
    return listt
#TC:O(n)
#SC:O(1) excluding output




