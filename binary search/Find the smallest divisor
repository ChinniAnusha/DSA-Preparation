#Approach:Brute force
#Source:Leetcode

class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
          for i in range(1,max(nums)+1):
               sum = 0
               for j in range(len(nums)):
                     sum += ceil(nums[j]/i)
               if sum <= threshold:
                     return i 
          return -1

#TC:O(max(arr[])*N)
#SC:O(1)

#optimal
class Solution:
    def smallestDivisor(self, nums: List[int], threshold: int) -> int:
         def sumofdivisors(arr,mid):
            n = len(arr)
            sum = 0
            for i in range(n):
                sum += ceil(arr[i]/mid)
            return sum
        
         low = 1
         high = max(nums)
         while low <= high:
            mid = (low+high)//2
            mini = sumofdivisors(nums,mid)
            if mini <= threshold:
                 ans = mid
                 high = mid - 1
            else:
                low = mid+1
         return low


#TC::O(log(max(arr[]))*N)
#SC:O(1)
