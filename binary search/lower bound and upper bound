#Approach: solved using binary search
#lower bound
#lower bound: we need to find the smallest index that is immediate greater or equal to given x so for that if arr[mid]>x
#that answer = mid it might be or may be cause they might other lower indices as well that are greater or equalto x that is why
#we written  high = mid - 1 and if arr[mid] <  x then definitely we have to low = mid + 1

def lowerbound(arr,n,x):
    low = 0
    high = n - 1
    answer = n
    while low <= high:
        mid = (low+high)//2
        if arr[mid] >= x:
            answer = mid
            high = mid - 1
        else:
            low = mid+1
    return answer
            
    
    
arr = list(map(int,input().split()))
n = len(arr)   
x = int(input())
print(lowerbound(arr,n,x))


#Upper bound
#upper bound:it follows same logic as lower bound but here smallest index should > x not >= x
def upperbound(arr,n,x):
    low = 0
    high = n - 1
    answer = n
    while low <= high:
        mid = (low+high) // 2
        if arr[mid] > x:
            answer = mid
            high = mid - 1
        else:
            low = mid + 1

    return answer

arr = list(map(int,input().split()))
n = len(arr)   
x = int(input())
print(upperbound(arr,n,x))
